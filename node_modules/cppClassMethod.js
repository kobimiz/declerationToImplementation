const { firstNonWSCharIndex, firstWSCharIndex } = require('utility');
const wordIterator = require('wordIterator');
class CPPClassMethod {
    constructor(className, name, returnType, parameters, isSpecialMember = false, isConst = false) {
        this.className = className;
        this.name = name;
        this.returnType = returnType;
        this.parameters = parameters;
        this.isSpecialMember = isSpecialMember;
        this.isConst = isConst;
    }

    toImplementationString() {
        // note that override should not appear in definition unless there it is also declaration
        let parametersString = '';
        this.parameters.forEach(parameter => {
            parametersString += parameter.toString() + ', ';
        });
        if (this.parameters.length !== 0) {
            // remove trailing ', '
            parametersString = parametersString.substring(0, parametersString.length - 2);
        }

        let constText = this.isConst ? 'const ' : '';
        if (!this.isSpecialMember)
            return this.returnType + ' ' + this.className + '::' + this.name + '(' + parametersString + ') ' + constText + '{\n\t\n}';
        return this.className + '::' + this.name + '(' + parametersString + ') ' + constText + '{\n\t\n}';
    }

    // assume syntax is good. special member is a constructor or a destructor
    static isSpecialMember(string) {
        // className(parameterType parameter1,....)
        // assume className really do fits the surrounding className since compilation is good
        return string.search(/[a-zA-Z_$][a-zA-Z_$0-9]*[\s\t\n]*\(.*\)/) !== -1;
    }

    // assume syntax is good
    static isMethodDeclaration(string) {
        // returnType name(parameterType parameter1,....)
        // NOTE that it is up to the compiler to check for syntax errors,
        // TODO consider adding signs like '&' and '<' to special member regex check
        // as the signature 'a><x name()' is accepted by this regex
        return string.search(/[a-zA-Z_$][a-zA-Z_$0-9:<>,\*\&]*\s+[a-zA-Z_$][a-zA-Z_$0-9]*[\s\t\n]*\(.*\)/) !== -1;
    }

    static isOperator(string) {
        // operators are + - * / % ^ & | ~ ! = < > += -= *= /= %= ^= &= |= << >> >>= <<= == != <= >= <=> && || ++ -- , ->* -> ( ) [ ]
        // NOTE it is up to the compiler to check for errors
        return string.search(/[a-zA-Z_$][a-zA-Z_$0-9:<>,\*\&]*\s+operator[+\-*/%^&|~!=<>,\(\)\[\]]{1,4}/) !== -1;
    }

    static parseMethod(className, string) {
        // 'const char* const * const* name  () [const] [override]' => 'const char* const * const*'
        // remove parameters for ease of use
        let parameterListStartIndex = string.lastIndexOf('(');
        let parameterListEndIndex = string.lastIndexOf(')');
        let isConst = string.indexOf('const', parameterListEndIndex) !== -1;
        
        // remove parameters for ease of use
        let wi = new wordIterator.WordIterator(string.substring(0, parameterListStartIndex));
        let name = wi.nextWordReverse().word;

        let returnType = string.substring(0, wi.nextWordReverse().endingIndex + 1);
        let parameterList = CPPClassMethod.parseParameterList(string.substring(parameterListStartIndex, parameterListEndIndex + 1));
        return new CPPClassMethod(className, name, returnType, parameterList, false, isConst);
    }

    // assume string is a valid special member. special member is a constructor
    // or a destructor can be checked with CPPClassMethod.isMethodDeclaration
    static parseSpecialMember(className, string) {
        // className(parameterType parameter1,....)
        // assume className really do fits the surrounding className since compilation is good
        let nameEnd = string.indexOf('(') - 1;
        let parameterListStart = nameEnd + 1;
        let parameterListEnd = string.lastIndexOf(')');

        let name = string.substring(0, nameEnd + 1);
        let parameterList = CPPClassMethod.parseParameterList(string.substring(parameterListStart, parameterListEnd + 1));
        return new CPPClassMethod(className, name, null, parameterList, true, false); //special member cant be const
    }

    // assume syntax is valid
    static parseParameterList(parameterList) {
        // handles cases where there are default parameters,
        // e.g. (Point topLeft   , int width, int height, Color&& color = Color(0.9f,0.9f,0.9f));
        parameterList = parameterList.substring(1, parameterList.length - 1); // trim both edges
        parameterList = CPPClassMethod.removeDefaultValues(parameterList);
        let parameters = parameterList.split(',');
        parameters.forEach((parameter, i) => {
            parameters[i] = parameter.trim();
        });
        return parameters;
    }

    // removes default values from a parameter list
    static removeDefaultValues(parameterList) {
        let output = '';
        let regEx = /=/g;
        let res;
        let prev = 0;
        while((res = regEx.exec(parameterList)) !== null) {
            output += parameterList.substring(prev, res.index);
            prev = parameterList.indexOf(',', res.index);
        }
        if (output == '')
            output = parameterList
        return output;
    }

    // whitespace chatacters are currently \s \t \n
    static isWSCharacter(char) {
        return char == ' ' || char == '\n' || char == '\t';
    }
}
exports.CPPClassMethod = CPPClassMethod;